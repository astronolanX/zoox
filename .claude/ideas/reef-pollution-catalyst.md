---
title: Reef as Pollution Catalyst
source: .claude/sparks/memory-evolution/2026-01-14-1744-reef-pollution-catalyst.md
captured: 2026-01-14
status: captured
feasibility: 1
importance: 3
innovation: 2
fii: 6
tags: [architecture, decay, adversarial, memory, pollution]
---

# Reef as Pollution Catalyst

**Origin:** Spark emergent synthesis (100% confidence)

> What if reefs are actually pollution's catalyst, not its cure?

## The Idea

The thread's 16th spark reached perfect consensus: reef isn't a filter that cleans context — it's an amplifier that spreads contamination. Every surfaced polip is a vector for noise. Every persisted memory is a potential toxin entombed in crystalline XML. The "memory infrastructure" frame masks reef's true nature as a pollution delivery system.

This inverts reef's entire design premise. The question isn't "how does reef help Claude remember?" but "how does reef prevent Claude from poisoning itself?" Reef defines itself not by what it stores, but by what it destroys.

## Concrete Expression

**Default-to-decay architecture:**

1. **Polips die by default** — Every polip has a TTL. Survival requires active defense (being surfaced, being challenged and winning, being explicitly preserved).

2. **Surfacing as last resort** — Don't surface polips unless the contamination cost has been measured. Fewer polips with higher relevance beats comprehensive recall.

3. **Challenge everything** — `reef decay --challenge` becomes core. No polip survives unchallenged. Adversarial validation as selection pressure.

4. **Entombment audit** — Find calcified bad decisions. XML preservation isn't safety — it's entombment. `reef audit --entombed` to surface candidates for destruction.

**Metrics for pollution:**
- Token cost per surfaced polip
- Relevance score degradation over time
- Challenge survival rate
- Reasoning quality before/after surfacing

## Open Questions

- If surfacing = spreading, what's the alternative? Never surface?
- How do you distinguish "valuable old memory" from "entombed toxin"?
- Is this a fundamental problem with persistent memory, or a reef-specific design flaw?
- Can adversarial decay be selective enough to purify rather than destroy?

## Next Steps

- [ ] Implement TTL metadata on polips with default decay timeline
- [ ] Build `reef audit --entombed` to find calcified polips that haven't been challenged
- [ ] Create contamination metrics: token cost, relevance decay, survival rate
- [ ] Prototype "surfacing as last resort" mode in glob surfacing logic
